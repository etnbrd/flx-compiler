<!DOCTYPE html>

<html>
<head>
  <title>Fluxion mapper</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, target-densitydpi=160dpi, initial-scale=1.0; maximum-scale=1.0; user-scalable=0;">
  <link rel="stylesheet" media="all" href="docco.css" />
</head>
<body>
  <div id="container">
    <div id="background"></div>
    
      <ul id="jump_to">
        <li>
          <a class="large" href="javascript:void(0);">Jump To &hellip;</a>
          <a class="small" href="javascript:void(0);">+</a>
          <div id="jump_wrapper">
          <div id="jump_page">
            
              
              <a class="source" href="index.html">
                index.js
              </a>
            
              
              <a class="source" href="core.html">
                core.js
              </a>
            
              
              <a class="source" href="context.html">
                context.js
              </a>
            
          </div>
        </li>
      </ul>
    
    <ul class="sections">
        
        
        
        <li id="section-1">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1">&#182;</a>
              </div>
              <h1 id="fluxion-mapper">Fluxion mapper</h1>

            </div>
            
        </li>
        
        
        <li id="section-2">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-2">&#182;</a>
              </div>
              <p>The compiler start by parsing the source to generate an Intermediate Representation (IR).
It uses the <a href="http://esprima.org/">esprima parser</a>, which generates an Abstract Syntax Tree (AST) according to the <a href="https://developer.mozilla.org/en-US/docs/Mozilla/Projects/SpiderMonkey/Parser_API">SpiderMonkey Parser API</a>.</p>

            </div>
            
        </li>
        
        
        <li id="section-3">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-3">&#182;</a>
              </div>
              <p>The compiler then generate a scope description object from the AST, using <a href="https://github.com/Constellation/escope">escope</a></p>

            </div>
            
        </li>
        
        
        <li id="section-4">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-4">&#182;</a>
              </div>
              <p>The pruner iterate over the AST to detect rupture points.
From a rupture point, a new fluxion is created containing the asynchronous execution.</p>

            </div>
            
        </li>
        
        
        <li id="section-5">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-5">&#182;</a>
              </div>
              <p>Each fluxion contains one or multiple function scopes.
The pruner map each function scope to the corresponding fluxion.
The linker uses this map to resolve variable dependencies.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-pi">
'use strict'</span>;

<span class="hljs-keyword">var</span> escope = <span class="hljs-built_in">require</span>(<span class="hljs-string">'escope'</span>),
    errors = <span class="hljs-built_in">require</span>(<span class="hljs-string">'../lib/errors'</span>),
    log = <span class="hljs-built_in">require</span>(<span class="hljs-string">'../lib/log'</span>),
    h = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./helpers'</span>);</pre></div></div>
            
        </li>
        
        
        <li id="section-6">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-6">&#182;</a>
              </div>
              <h2 id="flxscope">FlxScope</h2>

            </div>
            
        </li>
        
        
        <li id="section-7">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-7">&#182;</a>
              </div>
              <p>This object describe a fluxion</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">FlxScope</span><span class="hljs-params">(name, ast, root)</span> </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-8">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-8">&#182;</a>
              </div>
              <ul>
<li>The name of the fluxion is used to receives messages from other fluxions.</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="hljs-keyword">this</span>.name = name;</pre></div></div>
            
        </li>
        
        
        <li id="section-9">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-9">&#182;</a>
              </div>
              <ul>
<li>A fluxion is an independent execution unit, therefor we link the code from the original AST.</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="hljs-keyword">this</span>.ast = ast;</pre></div></div>
            
        </li>
        
        
        <li id="section-10">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-10">&#182;</a>
              </div>
              <ul>
<li>The code execution of a fluxion span over one or more function scopes.</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="hljs-keyword">this</span>.scopes = [];</pre></div></div>
            
        </li>
        
        
        <li id="section-11">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-11">&#182;</a>
              </div>
              <ul>
<li>A fluxion sends messages to downstream fluxions, each stream of message to a downstream fluxion is represented here as an output.</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="hljs-keyword">this</span>.outputs = [];</pre></div></div>
            
        </li>
        
        
        <li id="section-12">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-12">&#182;</a>
              </div>
              <ul>
<li>This fluxion receives messages from upstream fluxions.</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="hljs-keyword">this</span>.parents = [];</pre></div></div>
            
        </li>
        
        
        <li id="section-13">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-13">&#182;</a>
              </div>
              <ul>
<li>Is this fluxion the root of the stream.</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="hljs-keyword">this</span>.root = root;</pre></div></div>
            
        </li>
        
        
        <li id="section-14">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-14">&#182;</a>
              </div>
              <ul>
<li>The linker uses the function scope description to spot broken dependencies between fluxions.</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="hljs-keyword">this</span>.dependencies = {};</pre></div></div>
            
        </li>
        
        
        <li id="section-15">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-15">&#182;</a>
              </div>
              <ul>
<li>Varaible dependencies are of three types : <code>signature</code>, <code>scope</code> and <code>sync</code>.</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="hljs-keyword">this</span>.signature = {};
  <span class="hljs-keyword">this</span>.scope = {};
  <span class="hljs-keyword">this</span>.sync = {};
}

FlxScope.prototype.enter = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
  log.enter(<span class="hljs-string">'Enter flx '</span> + <span class="hljs-keyword">this</span>.name);
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
};

FlxScope.prototype.leave = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
  log.leave(<span class="hljs-string">'Leave flx '</span> + <span class="hljs-keyword">this</span>.name);
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
};

FlxScope.prototype._registerScopes = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(scopes)</span> </span>{
  scopes.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(n)</span> </span>{
    <span class="hljs-keyword">this</span>.scopes.push(n);
  }.bind(<span class="hljs-keyword">this</span>));
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
};

FlxScope.prototype._registerParent = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(parent, output)</span> </span>{
  <span class="hljs-keyword">this</span>.parents.push({parent: parent, output: output});
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
};

FlxScope.prototype._registerOutput = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(output)</span> </span>{
  log.info(<span class="hljs-keyword">this</span>.name + <span class="hljs-string">' // '</span> + output.source.name +  <span class="hljs-string">' -&gt; '</span> + output.dest.name);
  <span class="hljs-keyword">this</span>.outputs.push(output);
  <span class="hljs-keyword">this</span>.currentOutput = output;
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
};</pre></div></div>
            
        </li>
        
        
        <li id="section-16">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-16">&#182;</a>
              </div>
              <h2 id="output">Output</h2>

            </div>
            
        </li>
        
        
        <li id="section-17">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-17">&#182;</a>
              </div>
              <p>The compiler breaks a program into fluxion along rupture points (asynchronous calls).
At a rupture point, the fluxion sends a message to the downstream fluxion to replace the asynchronous call.
The output describes the stream between these two fluxions.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Output</span><span class="hljs-params">(name, type, params, sourceFlx, destFlx)</span> </span>{
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">formatParam</span><span class="hljs-params">(param)</span> </span>{
    <span class="hljs-keyword">return</span> {
      ast: param,
      name: param.name
    };
  }</pre></div></div>
            
        </li>
        
        
        <li id="section-18">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-18">&#182;</a>
              </div>
              <ul>
<li>The name of the destination fluxion.</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="hljs-keyword">this</span>.name = name;</pre></div></div>
            
        </li>
        
        
        <li id="section-19">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-19">&#182;</a>
              </div>
              <ul>
<li>The type of the rupture points : start, or post</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="hljs-keyword">this</span>.type = type;</pre></div></div>
            
        </li>
        
        
        <li id="section-20">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-20">&#182;</a>
              </div>
              <ul>
<li>The parameters to send for the destination fluxion to call either the callback in a start rupture point, or the asynchronous call in a post rupture point.</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="hljs-keyword">this</span>.params = params.map(formatParam);</pre></div></div>
            
        </li>
        
        
        <li id="section-21">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-21">&#182;</a>
              </div>
              <ul>
<li>The upstream fluxion.</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="hljs-keyword">this</span>.source = sourceFlx;</pre></div></div>
            
        </li>
        
        
        <li id="section-22">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-22">&#182;</a>
              </div>
              <ul>
<li>The downstream fluxion.</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="hljs-keyword">this</span>.dest = destFlx;</pre></div></div>
            
        </li>
        
        
        <li id="section-23">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-23">&#182;</a>
              </div>
              <ul>
<li>The signature of an output is the variables the upstream fluxion needs to send to make sure the scopes of every downstream fluxions are consistent.</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="hljs-keyword">this</span>.signature = {};
}

Output.prototype.registerSign = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(id)</span> </span>{
  log.sig(id.name + log.grey(<span class="hljs-string">' // '</span> + <span class="hljs-keyword">this</span>.source.name + <span class="hljs-string">' -&gt; '</span> + <span class="hljs-keyword">this</span>.dest.name));
  <span class="hljs-keyword">this</span>.signature[id.name] = {
    name: id.name,
    id: id,
    source: <span class="hljs-keyword">this</span>.source,
    dest: <span class="hljs-keyword">this</span>.dest
  };
};</pre></div></div>
            
        </li>
        
        
        <li id="section-24">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-24">&#182;</a>
              </div>
              <h2 id="context">Context</h2>

            </div>
            
        </li>
        
        
        <li id="section-25">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-25">&#182;</a>
              </div>
              <p>The context holds everything needed during the compilation :</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Context</span> <span class="hljs-params">(ast, filename)</span> </span>{

  <span class="hljs-keyword">var</span> currentFlx = <span class="hljs-keyword">new</span> FlxScope (filename, ast, <span class="hljs-literal">true</span>);</pre></div></div>
            
        </li>
        
        
        <li id="section-26">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-26">&#182;</a>
              </div>
              <ul>
<li>The filename</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="hljs-keyword">this</span>.name = filename;</pre></div></div>
            
        </li>
        
        
        <li id="section-27">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-27">&#182;</a>
              </div>
              <ul>
<li>The AST</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="hljs-keyword">this</span>.ast = ast;</pre></div></div>
            
        </li>
        
        
        <li id="section-28">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-28">&#182;</a>
              </div>
              <ul>
<li>Every fluxion</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="hljs-keyword">this</span>.flx = {};</pre></div></div>
            
        </li>
        
        
        <li id="section-29">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-29">&#182;</a>
              </div>
              <ul>
<li>Every function scope</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="hljs-keyword">this</span>.scopes = escope.analyze(ast).scopes;</pre></div></div>
            
        </li>
        
        
        <li id="section-30">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-30">&#182;</a>
              </div>
              <ul>
<li>Pointers to useful pieces of the context to use during the parse.</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="hljs-keyword">this</span>.currentFlx = currentFlx.enter();
  <span class="hljs-keyword">this</span>.currentScope = <span class="hljs-literal">undefined</span>;
  <span class="hljs-keyword">this</span>._stack = [currentFlx];
  <span class="hljs-keyword">this</span>._scopeStack = [];
  <span class="hljs-keyword">this</span>.fluxionTriggers = [];
}

Context.prototype.enterScope = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(n)</span> </span>{
  <span class="hljs-keyword">var</span> scopes = <span class="hljs-keyword">this</span>.scopes.filter(h.compareScopeByBlock(n));</pre></div></div>
            
        </li>
        
        
        <li id="section-31">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-31">&#182;</a>
              </div>
              <p>TODO on enter and on leave scope, we do the exact same things : count matching scopes, refactor that so that we donâ€™t duplicate code.
best with a shared state between the enter and leave, otherwise, with a shared function, or a factory.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
  scopes.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(scope)</span> </span>{
    <span class="hljs-keyword">var</span> name;

    scope.flx = <span class="hljs-keyword">this</span>.currentFlx;

    <span class="hljs-keyword">if</span> (scope.block.id)
      name = scope.block.id.name;
    <span class="hljs-keyword">if</span> (scope.block.type === <span class="hljs-string">'Program'</span>) {
      name = <span class="hljs-string">'Program'</span>;
    }


    <span class="hljs-keyword">this</span>._scopeStack.push(scope);
    <span class="hljs-keyword">this</span>.currentScope = scope;

    log.enter(<span class="hljs-string">'Enter scope '</span> + name);
  }.bind(<span class="hljs-keyword">this</span>));

  <span class="hljs-keyword">this</span>.currentFlx._registerScopes(scopes);

  <span class="hljs-keyword">return</span> scopes;
};

Context.prototype.leaveScope = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(n)</span> </span>{
  <span class="hljs-keyword">var</span> scopes = <span class="hljs-keyword">this</span>.scopes.filter(h.compareScopeByBlock(n));
   
  scopes.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(scope)</span> </span>{
    <span class="hljs-keyword">var</span> name;

    <span class="hljs-keyword">if</span> (scope.block.id)
      name = scope.block.id.name;
    <span class="hljs-keyword">if</span> (scope.block.type === <span class="hljs-string">'Program'</span>)
      name = <span class="hljs-string">'Program'</span>;

    scope = <span class="hljs-keyword">this</span>._scopeStack.pop();
    <span class="hljs-keyword">this</span>.currentScope = <span class="hljs-keyword">this</span>._scopeStack[<span class="hljs-keyword">this</span>._stack.length - <span class="hljs-number">1</span>];

    log.leave(<span class="hljs-string">'Leave scope '</span> + name);
  }.bind(<span class="hljs-keyword">this</span>));
};

Context.prototype.enterFlx = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(name, ast, type)</span> </span>{

  <span class="hljs-keyword">var</span> _oldFlx = <span class="hljs-keyword">this</span>.currentFlx,
    _newFlx = <span class="hljs-keyword">new</span> FlxScope(name, ast),
    _out;

  <span class="hljs-keyword">this</span>.currentFlx = _newFlx;
  <span class="hljs-keyword">this</span>._stack.push(_newFlx);

  <span class="hljs-keyword">if</span> (type) {
    _out = <span class="hljs-keyword">new</span> Output(name, type, ast.params, _oldFlx, <span class="hljs-keyword">this</span>.currentFlx);

    _newFlx._registerParent(_oldFlx, _out);
    _oldFlx._registerOutput(_out);
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">if</span> (name !== <span class="hljs-string">'Main'</span>) {
      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'entering a fluxion without an output'</span>);
    }
  }

  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.currentFlx.enter(name);
};

Context.prototype.leaveFlx = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
  <span class="hljs-keyword">var</span> flx = <span class="hljs-keyword">this</span>._stack.pop();
  <span class="hljs-keyword">this</span>.currentFlx = <span class="hljs-keyword">this</span>._stack[<span class="hljs-keyword">this</span>._stack.length - <span class="hljs-number">1</span>];
  <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.flx[flx.name]) {
    <span class="hljs-keyword">this</span>.flx[flx.name] = flx;
    <span class="hljs-keyword">return</span> flx.leave();
  }

  <span class="hljs-keyword">throw</span> errors.flxConflict(<span class="hljs-keyword">this</span>.currentFlx.name);
};


Context.prototype.registerModification = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(id)</span> </span>{
  <span class="hljs-keyword">this</span>.currentScope.references.filter(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(ref)</span> </span>{
    <span class="hljs-keyword">return</span> ref.identifier === id;
  }).forEach(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(ref)</span> </span>{
    ref.modified = <span class="hljs-literal">true</span>;
  });

  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
};

Context.prototype.registerFluxionTrigger = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(variableName)</span> </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.fluxionTriggers.push(variableName);
};

Context.prototype.isFluxionTrigger = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(ids)</span> </span>{
  <span class="hljs-keyword">return</span> ids.length === <span class="hljs-number">2</span> &amp;&amp; <span class="hljs-keyword">this</span>.fluxionTriggers.indexOf(ids[<span class="hljs-number">0</span>]) &gt; -<span class="hljs-number">1</span> &amp;&amp; ids[<span class="hljs-number">1</span>] === <span class="hljs-string">'get'</span>;
};

Context.prototype.end = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-32">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-32">&#182;</a>
              </div>
              <p>Leave the root fluxion</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="hljs-keyword">this</span>.leaveFlx();</pre></div></div>
            
        </li>
        
        
        <li id="section-33">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-33">&#182;</a>
              </div>
              <p>Populate dependencies</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="hljs-keyword">this</span>.scopes.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(scope)</span> </span>{
    scope.variables.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(variable)</span> </span>{
      <span class="hljs-keyword">if</span> (!h.reserved(variable.name)) {
        
        h.populate(variable);
        variable.flxs = {};
        variable.modifierFlxs = {};

        variable.references.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(ref)</span> </span>{
          <span class="hljs-keyword">var</span> name = ref.from.flx.name;
          <span class="hljs-keyword">var</span> flx = ref.from.flx;

          variable.flxs[name] = flx;
          <span class="hljs-keyword">if</span> (ref.modified) {
            variable.modifierFlxs[name] = flx;
          }

          <span class="hljs-keyword">if</span> (!flx.dependencies[variable.name]) {
            flx.dependencies[variable.name] = {
              source: variable.scope.flx,
              variable: variable,
              references: [ref],
              modified: ref.modified
            };
          } <span class="hljs-keyword">else</span> {
            flx.dependencies[variable.name].references.push(ref);
            flx.dependencies[variable.name].modified = ref.modified || flx.dependencies[variable.name].modified;
          }
        }, {});
      }
    });
  });
};

<span class="hljs-built_in">module</span>.exports = Context;</pre></div></div>
            
        </li>
        
    </ul>
  </div>
</body>
</html>
